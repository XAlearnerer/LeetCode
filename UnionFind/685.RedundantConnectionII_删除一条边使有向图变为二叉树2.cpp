#include<iostream>
#include<vector>

using namespace std;

struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};



//   这道题是之前那道Redundant Connection的拓展，那道题给的是无向图，
//   只需要删掉组成环的最后一条边即可，归根到底就是检测环就行了。
//   而这道题给我们的是有向图，那么整个就复杂多了，因为有多种情况存在，
//   比如给的例子1就是无环，但是有入度为2的结点3。再比如例子2就是有环，
//   但是没有入度为2的结点。其实还有一种情况例子没有给出，就是既有环，
//   又有入度为2的结点。好，我们现在就来总结一下这三种情况：
//   
//   第一种：无环，但是有结点入度为2的结点（结点3）
//   
//   [[1, 2], [1, 3], [2, 3]]
//   
//    1
//   / \
//   v   v
//   2-->3
//   
//   
//   第二种：有环，没有入度为2的结点
//   
//   [[1, 2], [2, 3], [3, 4], [4, 1], [1, 5]]
//   
//   5 <-1 -> 2
//   	^    |
//   	|    v
//   	4 <-3
//   
//   
//   	第三种：有环，且有入度为2的结点（结点1）
//   
//   	[[1, 2], [2, 3], [3, 1], [1, 4]]
//   
//     4
//     /
//     v
//     1
//   / ^
//   v    \
//   2 -->3
//   
//   
//   对于这三种情况的处理方法各不相同，
//   首先对于第一种情况，我们返回的产生入度为2的后加入的那条边[2, 3]，
//   而对于第二种情况，我们返回的是刚好组成环的最后加入的那条边[4, 1]，
//   最后对于第三种情况我们返回的是组成环，且组成入度为2的那条边[3, 1]。
//   
//   明白了这些，我们先来找入度为2的点，如果有的话，
//   那么我们将当前产生入度为2的后加入的那条边标记为second，
//   前一条边标记为first。然后我们来找环，为了方便起见，
//   找环使用联合查找Union Find的方法，可参见Redundant Connection中的解法三。
//   当我们找到了环之后，
//   如果first不存在，说明是第二种情况，我们返回刚好组成环的最后加入的那条边。
//   如果first存在，说明是第三种情况，我们返回first。
//   如果没有环存在，说明是第一种情况，我们返回second，


class Solution {
public:
	vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {

	}
};