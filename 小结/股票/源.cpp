////#include<iostream> //// ////using namespace std; //// ////class A ////{ ////public: ////	A() :b(100){ ////	} ////	int a = 10; ////	const int b = 11; ////	static const int e; ////	//int s[a]; //// ////}; //// ////const int A::e = 400; //// ////class B ////{ ////	const int c = 20; ////	static int d; ////public: ////	//B() ////	//{ ////	//	c = 200; ////	//} ////	int getc() ////	{ ////		return c; ////	} ////}; //// ////int B::d = 100; //// //// ////class foo { ////public: ////	foo() :i(100) {} ////private: ////	const int i = 100;//error!!! ////}; //// //// ////int main() ////{ ////	A q; ////	cout << q.a << " " << q.b << endl; //// ////	B p; ////	cout << p.getc() << endl; //// ////	return 0; ////} // // // //#include<iostream> // //using namespace std; // //class Ref //{ //public: //	// 构造函数形参为传值，不能保证正确性 //	// Ref (int target) :myref(target) { //	// cout << "Ref constructor" << endl; //	// } // //	// 函数体对引用赋值，编译错误：引用未初始化 //	// Ref (int &target)  { //	// myref = target; //	// cout << "Ref constructor" << endl; //	// } // //	// 如果成员为变量为引用类型，那么构造函数的参数为应用类型 //	// 引用必须在成员初始化链表里面初始化，不能在函数体里面初始化 //	// 在函数体里面修改myref，相当于赋值，显然引用不能赋值 //	Ref(int &target) :myref(target) { //		cout << "Ref constructor" << endl; //	} // //	void printRef() { //		cout << "myref is: " << myref << endl; //	} // //	virtual ~Ref() {} // //private: //	int &myref; //	/* data */ //}; // // // //int main(int argc, char *argv[]) //{ //	int a = 20; //	Ref r(a); //	r.printRef(); // //	int &b = a; //	Ref r1(b); //	r1.printRef(); // //	// error:引用定义时必须初始化 //	// int &c; // //	return 0; //} // // // // // //#include<iostream> // //using namespace std; // //int main() //{ //	//const int a = 10; //	//a = 20; //	//cout << a << endl; // //	cout << "MM" << endl; // //	return 0; //}  