  2.  while (l1 || l2){} 对进位的处理   4. 在两个有序数组中的二分查找   7. 注意数字的溢出 --- 注意 vs 中负数取余 负数取余，通过取模来判定 |小| % |大| = |小| 符号同前    |大| % |小| = |余| 符号同前 3%4 = 3 ； -3%4 = -3 ； -3%-4 = -3 ； 3%-4 = 3； 5%3 = 2 ； 5%-3 = 2  ；-5%-3 = -2 ； -5%3 = -2；    10. 点星匹配     23. 优先级序列的自定义 在 vs 中 要有  #include<functional>  才能 greater<int> priority_queue <int,vector<int>,greater<int> > q; priority_queue <int,vector<int>,cmp > q; struct cmp { 	bool operator()(ListNode* a, ListNode* b) 	{ 		return a->val > b->val; 	} }; 类比： sort(a,a+10,greater<int>()); 与 bool compare(int a,int b)  return a < b; sort(a,a+20,compare);    31. 下一个全排列的规律   32. 使用 栈 降低时间复杂度   46. 排列树  这次写的时候忘记了   48. 新的写法，先转置，再翻转 1  2  3　　　 　　 1  4  7　　　　　    7  4  1  4  5  6　　-->　　 2  5  8　　 -->  　  8  5  2　　  7  8  9 　　　 　　3  6  9　　　　      9  6  3   53. 注意 负数 的存在   55. 贪婪的算法设计    75. 使用i，j将区间分为三部分 注意：j与pos交换后 pos不能后移，因为pos的值未判断    76. for (auto i : t) ++v[i - 'a']; 忘记存在 A-Z 了 使用 for (auto i : t) ++v[i]; 即可    78. 字符串的所有子串 注意对比 90 与 1079 78      [1,2,3]  -->  [3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[] 90      [1,2,2]  -->  [2],[1],[1,2,2],[2,2],[1,2],[] 1079    AAB  -->  "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"    94. 遍历的非递归写法   105，106  重建二叉树    124 //int res = 0; int res = INT_MIN; 注意 负数 的存在 int l = max(helper(root->left, res), 0);    128 使用 find 更快    139 使用记忆数组memo来保存所有已经计算过的结果，再下次遇到的时候，直接从cache中取，而不是再次计算一遍。 这种使用记忆数组memo的递归写法，和使用dp数组的迭代写法，乃解题的两大神器，    146 LRU 缓存的实现 list 中 splice 函数的使用   148 链表的排序 归并 mid的查找    152 求 积最大子数列 的设计    207 有向图中找环  拓扑排序 dfs 图中各点的 入度    208 字典树    221 与 85 对比   234 注意 快慢指针 中这两者的区别 while (f && f->next) while(f->next && f->next->next)    236 没写出来 对比 1123    239 之前做过两遍，还是没想起来。。。。。   279 没思路，唉     287 要求 in place 且时间复杂度为不超过 O(n^2) 忘记咋做了。。。 二分的写法！！  1095   300 使用 lower_bound 优化的方法    301 哇 ，还是不会做   309 好难想呀  -。-   322 小心写错 状态转移    337 不是计算 奇偶行 的最大值 这个的设置也很有意思 二叉树的递归   